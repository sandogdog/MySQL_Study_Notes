记录一些浅显的小知识。

---

### 1.sql语句中的注释是“--”，记得在后面加一个空格才是你的注释内容。

---

### 2.mysql如何定位慢查询
![image](https://github.com/user-attachments/assets/85418c76-f804-4bed-a99d-5f16ca2975b5)

![image](https://github.com/user-attachments/assets/b53918b7-9806-43b1-9426-97159f14ec49)

---

### 3.sql语句执行的很慢，如何分析
![image](https://github.com/user-attachments/assets/c422a946-42b5-4c66-887d-e87892c614e9)

![image](https://github.com/user-attachments/assets/7cbbd110-dd4b-4464-a05a-f65bdb9e3a36)

![image](https://github.com/user-attachments/assets/f6bea458-9452-4449-b545-d7d17268f855)

![image](https://github.com/user-attachments/assets/42f8f2aa-bd4e-4939-b266-453b904dfefe)

![image](https://github.com/user-attachments/assets/04f040c4-239c-4067-be62-03aa2c1b692f)

---

### 4.索引概念及索引底层数据结构
![image](https://github.com/user-attachments/assets/843c654a-0426-4ecf-865c-731148e94124)

![image](https://github.com/user-attachments/assets/6e26ff0e-7160-4f8b-aa4d-4663f2925c97)

![image](https://github.com/user-attachments/assets/62f35052-3750-4f63-8d8c-6aad585884b2)

![image](https://github.com/user-attachments/assets/76a8ddba-f787-4d07-9771-72ab751c435f)

![image](https://github.com/user-attachments/assets/e202f49a-b46e-41a5-bc5a-a8d3af58ad6b)

![image](https://github.com/user-attachments/assets/40ffa6ee-7b45-44bd-8815-77d2bd9c2ab1)

![image](https://github.com/user-attachments/assets/376eaa5c-02e4-4ad7-9970-1130f592ef6f)

---

### 5.聚簇索引和非聚簇索引、回表查询
![image](https://github.com/user-attachments/assets/1ac163c8-9a2c-47dd-b759-1e171f8f8566)

![image](https://github.com/user-attachments/assets/767ecb1b-7c7b-4119-aa94-427d7355ac79)

![image](https://github.com/user-attachments/assets/0f2c780e-cf54-45b9-9a33-29ee292d3445)

![image](https://github.com/user-attachments/assets/0a85aa98-c0a2-42d2-b343-55b9375c4c92)

![image](https://github.com/user-attachments/assets/1fd501df-cc6a-467c-b728-693c80f3cddd)

---

### 6.覆盖索引、超大分页优化
![image](https://github.com/user-attachments/assets/a03e28a8-093a-465e-a18f-5b7aa3220b41)

![image](https://github.com/user-attachments/assets/f0d92a16-ef78-497e-9fbb-e6a87c26745a)

![image](https://github.com/user-attachments/assets/250b6546-0d6e-4156-91cd-533d2face496)

![image](https://github.com/user-attachments/assets/057e9e7a-76f0-4385-9219-257204a11ae6)

![image](https://github.com/user-attachments/assets/b2d066a9-7a1f-420e-b1ec-89be0163d00c)

![image](https://github.com/user-attachments/assets/a18f9a99-b6ef-4bdf-a654-71f4a5d6fe4f)

---

### 7.索引创建的原则
![image](https://github.com/user-attachments/assets/e23a37ca-035d-4548-b68c-733c430a4d4d)

![image](https://github.com/user-attachments/assets/caf1e840-47db-4217-a3fb-ee990793eafa)

![image](https://github.com/user-attachments/assets/baec9092-ee7a-4336-bec2-213b2463ece4)

---

### 8.什么情况下索引会失效
![image](https://github.com/user-attachments/assets/e058f9af-d73f-4939-9d9c-7745ce7bc447)

![image](https://github.com/user-attachments/assets/7199b773-68f8-4236-b9b3-a4dc2b440ca7)

![image](https://github.com/user-attachments/assets/3b7455ac-95a8-4453-8a07-618fa1b716b0)

![image](https://github.com/user-attachments/assets/fa46035a-0965-45c8-89a3-84a8729294fa)

![image](https://github.com/user-attachments/assets/95bdcbf5-f545-4665-abe5-a9b6024d07ae)

![image](https://github.com/user-attachments/assets/99d3c60a-23c9-4933-aa3a-dd685fa4f3dc)

![image](https://github.com/user-attachments/assets/ddd86d99-fd5a-441a-acdb-7982680c06c7)

![image](https://github.com/user-attachments/assets/4a9753e1-4dd3-4762-bf89-6a247bb7e028)

---

### 9.谈一谈你对sql优化的经验
![image](https://github.com/user-attachments/assets/4914fed0-7367-4d4c-be12-b278eefdbea4)

![image](https://github.com/user-attachments/assets/164d1d25-d07c-4964-93df-6cff9617cb4d)

![image](https://github.com/user-attachments/assets/4e97f48c-e127-499b-9fd9-cf3ad4000187)

![image](https://github.com/user-attachments/assets/11dafdd1-6c1f-437b-9e6e-8e4831401efb)

![image](https://github.com/user-attachments/assets/9e5be1ce-1241-49e3-8c74-ec7f9d0c831d)

---

### 10.事务的特性

![image](https://github.com/user-attachments/assets/4f15de3f-4580-42b6-8cb0-fc786d4c638a)

![image](https://github.com/user-attachments/assets/7e859bfd-b59e-4ea9-9458-7038ecc83f39)

![image](https://github.com/user-attachments/assets/c29c0d8f-3630-4dda-8391-d62e3e8338fa)

---

### 11.并发事务问题、隔离级别

![image](https://github.com/user-attachments/assets/8a184718-dbe9-4c1e-b96a-8913d9e3e43b)

![image](https://github.com/user-attachments/assets/682fe310-f4a4-4c5b-a435-bc478972e1b2)

![image](https://github.com/user-attachments/assets/6bfe18b5-069f-492a-a127-4b7fe00d1dd2)

![image](https://github.com/user-attachments/assets/1e2c6b22-7d29-432a-938d-47b7ade63332)

![image](https://github.com/user-attachments/assets/f462f617-c2c6-4809-ab4f-cff8f6532ed3)

---

### 12.undo log 和redo log的区别

![image](https://github.com/user-attachments/assets/12476f00-98d9-4c08-aa53-a97537a2944a)

![image](https://github.com/user-attachments/assets/e79467e4-525f-4c31-a0fe-aed55c55dc62)

![image](https://github.com/user-attachments/assets/712a8468-0c8e-4c49-9c68-3a88289fbd3b)

![image](https://github.com/user-attachments/assets/de54a176-8c6a-41f4-80ec-88b92ad56a99)

---

### 13.解释一下mvcc

![image](https://github.com/user-attachments/assets/5b679d7b-cfbe-4938-a55d-db9305c23662)

![image](https://github.com/user-attachments/assets/ec71281a-7df4-49f2-b028-f13490346347)

![image](https://github.com/user-attachments/assets/fd2fde51-3d23-4946-928b-331cb4003acc)

![image](https://github.com/user-attachments/assets/46716fd5-f45d-4035-bb2d-60b9e99b6b24)

![image](https://github.com/user-attachments/assets/d99a44a3-1cde-4305-913c-26e071fe9bcb)

![image](https://github.com/user-attachments/assets/386843ba-8b53-4d9e-beac-9c2d1f4743c9)

![image](https://github.com/user-attachments/assets/85e87ab0-1f23-4753-b5bf-7a9f0f958f57)

![image](https://github.com/user-attachments/assets/f46b01b2-922f-4a3d-859e-a56d11d48b7a)

![image](https://github.com/user-attachments/assets/e7b1e400-36cd-4859-b333-aa6fa6d1ba76)

![image](https://github.com/user-attachments/assets/d30ef714-a827-4897-aa2e-220f2584ab07)

![image](https://github.com/user-attachments/assets/77e76684-42bc-4440-baf6-e67a49b1d171)

---

### 14.主从同步原理

![image](https://github.com/user-attachments/assets/c7848fbc-b7af-44f4-9fc7-ae5e01f0a0ea)

![image](https://github.com/user-attachments/assets/ad53f232-710b-4650-aea8-d8ce68faa5fe)

---

### 15.分库分表

![image](https://github.com/user-attachments/assets/982613e8-169c-4aff-92e4-40043ad01cd2)

![image](https://github.com/user-attachments/assets/b7f4c302-15f9-4e9d-ad9a-8ac640e082f8)

![image](https://github.com/user-attachments/assets/6f6494f7-705a-444d-a8a2-6b65b3602fea)

![image](https://github.com/user-attachments/assets/ea6edb51-cb58-49c1-a250-5322996cd100)

![image](https://github.com/user-attachments/assets/fb09e256-761b-4555-bfd7-cc845c952e91)

![image](https://github.com/user-attachments/assets/6eef1cee-ffa9-4485-995c-3de55a750720)

![image](https://github.com/user-attachments/assets/e4fcff1d-1d58-4bf6-9d75-4603144c8466)

![image](https://github.com/user-attachments/assets/9df04e9b-460a-4ccf-a56e-380dd08524f6)

---

### 16.在 MySQL 中，**`DISTINCT`** 是一个关键字，用于从查询结果中**去除重复的记录**。它通常用于 **`SELECT`** 语句中，帮助我们返回唯一的值，避免重复的行显示在结果集里。

**语法**：  
```sql
SELECT DISTINCT column1, column2, ... 
FROM table_name;
```

**使用方法**：  
1. **去除单列的重复值**：  
   当你只关心某一列的唯一值时，可以使用 **`DISTINCT`** 去重。例如，假设你有一个员工表，想查询所有不同的职位：  

   ```sql
   SELECT DISTINCT job_title
   FROM employees;
   ```
   这个查询会返回表中所有**不重复的职位**。

2. **去除多列的重复值**：  
   如果查询结果包含多个列，**`DISTINCT`** 会确保所有列组合的唯一性。只有当所有列的组合完全相同，才会被视为重复并去除。例如：

   ```sql
   SELECT DISTINCT first_name, last_name
   FROM employees;
   ```

   这个查询会返回不同的名字和姓氏的组合，如果两个员工有相同的名字和姓氏，这一组合只会显示一次。

**注意事项**：  
- **`DISTINCT`** 是应用在整个行级别的，而不仅仅是单个列。当你选择多个列时，所有列的值组合被认为是唯一的。  
  
- **`DISTINCT`** 会增加查询的计算开销，尤其是在数据量较大的时候，因此在性能要求较高的情况下，尽量避免不必要的 **`DISTINCT`** 使用。  
  
**示例**：  
1. 查询不同的城市：  
假设有一个订单表，包含以下数据：  
| id  | customer_name | city     |  
|-----|---------------|----------|  
| 1   | John          | New York |  
| 2   | Jane          | Boston   |  
| 3   | Mike          | New York |  
| 4   | Sarah         | Chicago  |

使用 **`DISTINCT`** 查询唯一的城市：  

```sql
SELECT DISTINCT city
FROM orders;
```

结果：  
| city     |  
|----------|  
| New York |  
| Boston   |  
| Chicago  |

2. 查询不同的名字和城市组合： 
假设表数据如下：  
| id | customer_name | city     |  
|----|---------------|----------|  
| 1  | John          | New York |  
| 2  | Jane          | Boston   |  
| 3  | Mike          | New York |  
| 4  | John          | Chicago  |

查询不同的名字和城市组合：  

```sql
SELECT DISTINCT customer_name, city
FROM orders;
```

结果：  
| customer_name | city     |  
|---------------|----------|  
| John          | New York |  
| Jane          | Boston   |  
| Mike          | New York |  
| John          | Chicago  |

**总结**：  
- **`DISTINCT`** 用于消除查询结果中的重复数据。  
- 它适用于**单列**和**多列**查询，但性能开销可能较大，尤其在数据量大的时候。  
- **`DISTINCT`** 会根据整个行的数据来判断是否重复，并不是单纯根据某一列来去重。

---

### 17.在mysql中你如何验证查询结果的准确性？

在 MySQL 中，验证查询结果的准确性是确保数据完整性、业务逻辑正确性以及系统功能正常的关键步骤。根据不同的测试需求，可以采取以下方法来验证查询结果的准确性：

#### **1. 手动检查数据一致性**

通过手动查询并检查数据，确保查询结果与预期一致。比如，你可以使用 `SELECT` 查询来查看表中数据的状态，或者对比数据源（例如，从其他系统导入的数据）与查询结果。

```sql
SELECT * FROM orders WHERE order_id = 123;
```

手动检查此查询结果，确保 `order_id` 为 123 的订单信息符合预期。

#### **2. 使用 `COUNT()` 检查数据量**

对于需要验证某个条件下的数据条数是否正确的情况，可以使用 `COUNT()` 函数。例如，验证某个用户的订单数量是否正确：

```sql
SELECT COUNT(*) FROM orders WHERE user_id = 456;
```

通过与预期的条数进行对比，确认查询结果的准确性。

#### **3. 比较查询结果与预期值**

在自动化测试中，你可能会用 **测试框架**（如 **JUnit**、**TestNG** 等）或 **Postman** 配合 **SQL** 查询进行验证。可以编写 SQL 查询并将其结果与预期值进行比较。例如，验证某个订单的总价是否符合计算公式：

```sql
SELECT total_price FROM orders WHERE order_id = 123;
```

- 通过编程语言（如 Java）或测试工具，将查询结果与预期的 `total_price` 比较，如果一致则验证成功。

#### **4. 验证数据完整性**

验证查询结果是否包含所有必要的字段，并且字段值符合业务逻辑。例如，确保查询出来的某个订单包含订单号、用户 ID、商品数量、总价等必要字段。如果某个字段值为空或者不符合预期，那么查询结果就不准确。

```sql
SELECT order_id, user_id, product_id, quantity, total_price
FROM orders WHERE order_id = 123;
```

检查返回的字段是否全部存在并且正确。

#### **5. 使用 `JOIN` 验证多表数据的关联性**

当查询涉及多个表时，使用 `JOIN` 语句将数据联结起来，并确保查询结果在各表之间的关联性是正确的。例如，验证某个订单及其相关的用户信息：

```sql
SELECT o.order_id, o.total_price, u.username
FROM orders o
JOIN users u ON o.user_id = u.user_id
WHERE o.order_id = 123;
```

确保返回的 `order_id`、`total_price` 和 `username` 都符合预期，且它们在各自的表之间关联正确。

#### **6. 使用 `GROUP BY` 和聚合函数验证数据的汇总正确性**

如果需要验证聚合数据（如总计、平均值等），可以使用 `GROUP BY` 和聚合函数（如 `SUM()`, `AVG()`, `MAX()`, `MIN()` 等）。例如，验证某个时间段内所有订单的总金额是否符合预期：

```sql
SELECT SUM(total_price) FROM orders WHERE order_date BETWEEN '2025-01-01' AND '2025-01-31';
```

与预期结果对比，验证结果是否准确。

#### **7. 数据一致性校验**

如果你的应用有多个数据库或表涉及相同数据，你可能需要进行数据一致性验证，确保不同表中的相关数据一致。例如，验证 `orders` 表和 `payments` 表中的订单总额是否一致：

```sql
SELECT o.order_id, o.total_price, p.payment_amount
FROM orders o
JOIN payments p ON o.order_id = p.order_id
WHERE o.order_id = 123;
```

确保两个表中关于该订单的数据一致。

#### **8. 边界测试与异常值验证**

对于数字、日期等数据类型，可以进行边界测试，验证在边界条件下查询结果是否正确。例如，验证价格是否在合理范围内，或者日期是否符合预期：

```sql
SELECT order_id, total_price
FROM orders
WHERE total_price BETWEEN 0 AND 10000;
```

确保查询结果的 `total_price` 落在合适的范围内。

#### **9. 使用事务（Transaction）验证数据**

在数据库中，如果你在多次操作后需要确保数据的一致性，可以使用事务来进行验证。通过 **事务**，你可以在测试时模拟对数据库的多次操作，并在最后回滚或提交这些操作，以验证数据是否正确更新。

```sql
START TRANSACTION;
UPDATE orders SET total_price = 200 WHERE order_id = 123;
SELECT * FROM orders WHERE order_id = 123;
ROLLBACK; -- 回滚
```

回滚后，数据库应恢复到操作前的状态。

#### **10. 比较查询结果与原始数据的预期输出**

如果你有一份数据文件或数据源（例如 Excel、CSV 文件），可以直接对比查询结果和预期输出的结果。这个方法适用于批量验证查询结果。

```sql
SELECT * FROM products WHERE category = 'electronics';
```

将查询结果与预期的产品数据进行逐一对比。

---

#### **总结：**

在 MySQL 中验证查询结果的准确性，可以通过以下方式：
1. **手动检查** 数据一致性和预期值。
2. **使用 `COUNT()`** 验证条数是否正确。
3. **比较查询结果与预期值**，例如价格、数量等。
4. **验证数据完整性**，确保所有必要的字段都存在且准确。
5. **`JOIN` 操作** 检查多表数据的关联性。
6. **聚合函数**（如 `SUM()`, `AVG()`, `MAX()`）验证数据汇总的准确性。
7. **数据一致性校验**，确保不同表中的相关数据一致。
8. **边界测试**，验证数据的有效范围。
9. **事务控制**，在多次操作后验证数据一致性。

这些方法可以帮助确保数据库查询结果的准确性，并发现潜在的问题或异常。
